Chris:
Our project was the addition of users and security to JOS.

There are three parts to this security system:
1. User Authentication - Check user/password pairs to grant access to system
2. File Permissions - Permissions are associated with each file and
	may be used to determine what a specific user may do with a file.
3. Environment Permissions - Associate a user and group with each
	running environment, and use this to restrict access to protected 
	resources. The FS server uses this in file permission checking, and the
	network server uses this to restrict access to reserved port numbers.

The SECURITY SERVER manages user authentication. Users and their
associated password hashes are stored in the /passwd file on disk.
The security server's interface consists of: get_user_by_id, 
get_user_by_name, and verify_password. The first two functions 
are used to return a struct user_info with information about the user
referenced by name or uid. The last function is used to verify a 
uid/password pair to grant access for login. The security server runs
as the root user, and is therefore able to access the /passwd file for 
reading.

The /passwd file follows the standard Linux format. Users are entered 
one per line and consist of: username, hashed password, uid, gid, comments,
home directory, and shell. The password hash uses a nonstandard 
option. Hashes are simple SHA-256 hashes of the password prefixed
with "{JOS}" to tell them apart from the various crypt(3) implementations.
An open source SHA-2 library is used in the contrib/ folder of the repo.

File system permissions were added through the addition of new 
fields to struct File. These fields give the owner uid, gid, and 
permissions. The permissions are the standard octal permissions used
in Linux without support for sticky or set{uid,gid} bits.




Rob:

Login:
We created a seperate login environment that will prompt the user for a username and password. The login environment communicates via IPC with the security server, which authenticates the user. If the user successfully enters a correct username and password, the login environment will spawn a new shell environment that has the UID (user id) specified by the security response.

Filesystem Permission Check:
We've added an additional check to the filesystem when the file server recieves an IPC. Before it starts reacting to the incoming IPC message, the server calls has_perm, which will determine whether the calling environment has the correct permissions to execute what is requesting to do. The permissions are calculated via the file descriptor's gid,uid, and perm fields agains the calling environment's gid,uid, and request type (i.e. FSREQ_OPEN). The has_perm function handles each request type differently.

chown:
The chown command takes in a username and filename, and it changes the owner of that file. It uses the security server to retrieve the uid of the user argument and sends off an IPC to the file server. The file server only lets the root user execute the Chown command. This command can take in and execute on an arbitrary number of files.

chgrp:
The chgrp command takes in a gid (group id) and filename, and it changes the group of that file. This sends an IPC to the file server, which checks to makes sure that the calling environment is both the owner of the file and is in the group identified by the gid argument. If these checks pass, then the file server changes the file's gid to the inputted gid. This command can take in and execute on an arbitrary number of files

chmod:
The chmod command takes in a octal number and filename, and it changes the file's permission to the inputted octal. The octal must be 3 octal digits, else the command will complain. chmod sends an IPC to the file server, which will make sure the calling environment is the owner of that file (only the owner or root can execute this command). If that check passes, the file permission is changed to the input octal provided by the user.
